<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚ù§Ô∏è‚Äçüî• Lovefield ‚Äî 2D DOM Map</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #050510;
      --bg-alt: rgba(15, 18, 45, 0.65);
      --glass: rgba(120, 165, 255, 0.16);
      --glass-border: rgba(120, 205, 255, 0.45);
      --glass-highlight: rgba(255, 120, 220, 0.55);
      --text-primary: #f6f9ff;
      --text-muted: rgba(236, 240, 255, 0.72);
      --accent: #ff8bd1;
      --accent-secondary: #77ffe2;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background:
        radial-gradient(140% 140% at 50% -20%, rgba(255, 120, 220, 0.18), transparent 50%),
        radial-gradient(160% 120% at 50% 140%, rgba(119, 255, 226, 0.16), transparent 65%),
        linear-gradient(170deg, #07071d 0%, #050512 45%, #04040b 100%);
      font-family: 'Sarabun', 'Inter', system-ui, -apple-system, sans-serif;
      color: var(--text-primary);
      position: relative;
    }

    #stage {
      position: relative;
      width: 100%;
      height: 100%;
      perspective: 1400px;
      overflow: hidden;
      isolation: isolate;
    }

    .map-layer,
    .field-layer,
    .entity-layer,
    .bubble-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .map-layer {
      background-image:
        linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
      background-size: 110px 110px;
      filter: saturate(0.9) brightness(0.92);
    }

    .map-road {
      position: absolute;
      background: rgba(120, 140, 190, 0.35);
      border: 1px solid rgba(140, 160, 220, 0.4);
      border-radius: 40px;
      box-shadow:
        0 18px 32px rgba(20, 20, 45, 0.35) inset,
        0 8px 22px rgba(0, 0, 0, 0.35);
      opacity: 0.85;
    }

    .map-road::after {
      content: '';
      position: absolute;
      inset: 12px 0;
      border-radius: 20px;
      background: repeating-linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.12),
        rgba(255, 255, 255, 0.12) 24px,
        transparent 24px,
        transparent 54px
      );
      opacity: 0.7;
    }

    .map-road.vertical::after {
      inset: 0 12px;
      background: repeating-linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.12),
        rgba(255, 255, 255, 0.12) 24px,
        transparent 24px,
        transparent 54px
      );
    }

    .map-pond {
      position: absolute;
      width: 160px;
      height: 110px;
      border-radius: 60% 55% 70% 45%;
      background: radial-gradient(circle at 30% 30%, rgba(77, 255, 236, 0.5), rgba(33, 118, 255, 0.3) 45%, rgba(8, 28, 60, 0.6));
      border: 1px solid rgba(77, 255, 236, 0.5);
      box-shadow: 0 20px 50px rgba(20, 60, 120, 0.45);
      filter: blur(0.1px);
    }

    .map-poi {
      position: absolute;
      font-size: 46px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 70px;
      height: 70px;
      border-radius: 22px;
      background: rgba(15, 18, 48, 0.7);
      border: 1px solid rgba(120, 205, 255, 0.4);
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.45);
      text-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
    }

    .map-poi::after {
      content: attr(data-label);
      position: absolute;
      top: 76px;
      white-space: nowrap;
      font-size: 11px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(236, 240, 255, 0.6);
    }

    .mds-entity {
      position: absolute;
      font-size: 50px;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
      filter: drop-shadow(0 18px 32px rgba(255, 120, 220, 0.45));
      pointer-events: auto;
    }

    .mds-entity:hover {
      transform: translateZ(24px) scale(1.16);
      filter: drop-shadow(0 26px 44px rgba(182, 153, 255, 0.7));
    }

    .mds-entity.legacy-skin {
      font-size: 42px;
      padding: 8px 12px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(18, 22, 48, 0.9), rgba(18, 22, 40, 0.6));
      border: 1px solid var(--legacy-accent, rgba(182, 153, 255, 0.5));
      box-shadow:
        0 18px 40px -18px rgba(0, 0, 0, 0.8),
        0 0 60px rgba(182, 153, 255, 0.35);
    }

    .mds-entity.legacy-skin::after {
      content: attr(data-surface);
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 9px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--legacy-accent, rgba(182, 153, 255, 0.56));
      background: rgba(8, 10, 30, 0.85);
      color: rgba(244, 247, 255, 0.58);
    }

    .mds-field {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      border: 1px solid rgba(182, 153, 255, 0.5);
      box-shadow: 0 0 140px rgba(255, 120, 220, 0.36), 0 0 100px rgba(182, 153, 255, 0.28);
      animation: field-pulse 4.2s ease-in-out infinite;
      mix-blend-mode: screen;
    }

    .mds-field[data-kind="bond"] {
      border-color: rgba(255, 140, 210, 0.8);
      background: radial-gradient(circle, rgba(255, 140, 210, 0.32) 0%, rgba(255, 120, 220, 0.16) 52%, transparent 100%);
    }

    .mds-field[data-kind="tension"] {
      border-color: rgba(255, 104, 120, 0.85);
      background: radial-gradient(circle, rgba(255, 104, 120, 0.22) 0%, rgba(255, 104, 120, 0.1) 55%, transparent 100%);
      animation: tension-pulse 2.6s ease-in-out infinite;
    }

    .mds-field[data-kind="memory"] {
      border-color: rgba(119, 255, 226, 0.6);
      background: radial-gradient(circle, rgba(119, 255, 226, 0.24) 0%, rgba(119, 255, 226, 0.1) 60%, transparent 100%);
      animation: memory-pulse 6s ease-in-out infinite;
    }

    @keyframes field-pulse {
      0%, 100% { opacity: 0.55; transform: scale(1); }
      50% { opacity: 0.85; transform: scale(1.12); }
    }

    @keyframes tension-pulse {
      0%, 100% { opacity: 0.62; transform: scale(1); filter: blur(0px); }
      40% { opacity: 0.45; transform: scale(0.94); filter: blur(1px); }
      70% { opacity: 0.85; transform: scale(1.08); }
    }

    @keyframes memory-pulse {
      0%, 100% { opacity: 0.42; transform: scale(1); }
      60% { opacity: 0.75; transform: scale(1.16); }
    }

    .bubble {
      position: absolute;
      min-width: 150px;
      max-width: 280px;
      background: rgba(8, 12, 32, 0.88);
      border: 1px solid rgba(120, 205, 255, 0.32);
      border-radius: 16px;
      padding: 12px 16px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-primary);
      transform: translate(-50%, -120%);
      animation: bubble-float 5s ease-out forwards;
      pointer-events: none;
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 38px rgba(0, 0, 0, 0.45);
      z-index: 5;
    }

    .bubble[data-tone="tension"] {
      border-color: rgba(255, 104, 120, 0.55);
    }

    .bubble[data-tone="memory"] {
      border-color: rgba(119, 255, 226, 0.45);
    }

    @keyframes bubble-float {
      0% { opacity: 0; transform: translate(-50%, -110%) scale(0.9); }
      15% { opacity: 1; transform: translate(-50%, -128%) scale(1.04); }
      80% { opacity: 1; transform: translate(-50%, -155%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -178%) scale(0.92); }
    }

    .liquid-orb {
      position: fixed;
      top: 40px;
      right: 40px;
      width: 220px;
      padding: 18px 20px;
      border-radius: 24px;
      background: var(--glass);
      backdrop-filter: blur(22px);
      border: 1px solid var(--glass-border);
      box-shadow:
        0 25px 60px rgba(10, 15, 45, 0.45),
        inset 0 0 25px rgba(120, 205, 255, 0.12);
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 6;
    }

    .liquid-orb.orb-feed {
      top: auto;
      right: 40px;
      bottom: 40px;
      width: 280px;
    }

    .liquid-orb.orb-map {
      top: 40px;
      left: 40px;
      right: auto;
      width: 260px;
    }

    .orb-title {
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(236, 240, 255, 0.68);
    }

    .orb-body {
      display: grid;
      gap: 8px;
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .orb-body strong {
      color: var(--text-primary);
      letter-spacing: 0.08em;
    }

    .control-dock {
      position: fixed;
      left: 40px;
      bottom: 40px;
      display: flex;
      gap: 12px;
      padding: 12px 16px;
      border-radius: 18px;
      background: rgba(10, 14, 36, 0.72);
      border: 1px solid rgba(120, 205, 255, 0.28);
      backdrop-filter: blur(18px);
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
      pointer-events: auto;
      z-index: 6;
    }

    .btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 14px;
      border: 1px solid rgba(119, 255, 226, 0.32);
      background: rgba(119, 255, 226, 0.14);
      color: var(--text-primary);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease, border 0.2s ease;
    }

    .btn:hover {
      transform: translateY(-2px);
      background: rgba(119, 255, 226, 0.24);
      border-color: rgba(119, 255, 226, 0.6);
    }

    .btn:active {
      transform: translateY(0);
    }

    @media (max-width: 960px) {
      .liquid-orb {
        width: 200px;
        padding: 16px;
        right: 24px;
      }

      .liquid-orb.orb-feed {
        bottom: 24px;
      }

      .liquid-orb.orb-map {
        left: 24px;
      }

      .control-dock {
        left: 24px;
        bottom: 24px;
        flex-wrap: wrap;
      }

      .btn {
        flex: 1 1 120px;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="stage">
    <div class="map-layer">
      <div class="map-road" style="top: 45%; left: 5%; width: 90%; height: 70px;"></div>
      <div class="map-road vertical" style="top: 8%; left: 48%; width: 70px; height: 84%;"></div>
      <div class="map-road" style="top: 22%; left: 18%; width: 70%; height: 46px; transform: rotate(-10deg);"></div>
      <div class="map-road" style="top: 68%; left: 18%; width: 70%; height: 48px; transform: rotate(8deg);"></div>
      <div class="map-pond" style="top: 20%; left: 12%;"></div>
      <div class="map-pond" style="top: 70%; left: 75%; width: 140px; height: 100px; border-radius: 55% 60% 45% 70%;"></div>
      <div class="map-poi" data-label="Aurora Tower" style="top: 18%; left: 56%;">üèôÔ∏è</div>
      <div class="map-poi" data-label="Skate Plaza" style="top: 35%; left: 26%;">üõπ</div>
      <div class="map-poi" data-label="Neon Arcade" style="top: 58%; left: 64%;">üïπÔ∏è</div>
      <div class="map-poi" data-label="Night Market" style="top: 68%; left: 32%;">üõçÔ∏è</div>
      <div class="map-poi" data-label="Glass Labs" style="top: 28%; left: 78%;">üî¨</div>
      <div class="map-poi" data-label="Rooftop Stage" style="top: 48%; left: 12%;">üé§</div>
    </div>
    <div class="field-layer" id="field-layer"></div>
    <div class="entity-layer" id="entity-layer"></div>
  </div>

  <div class="liquid-orb orb-map">
    <div class="orb-title">Lovefield Map</div>
    <div class="orb-body" id="orb-map-body">
      <p>Using DOM info-physics to host emergent town drama.</p>
      <p>MBTI traits nudge how teens bond, spark, and drift across emoji blocks.</p>
    </div>
  </div>

  <div class="liquid-orb" id="orb-stats">
    <div class="orb-title">HUD</div>
    <div class="orb-body">
      <p>Population <strong id="stat-pop">0</strong></p>
      <p>Bonds <strong id="stat-bonds">0</strong> ¬∑ Breakups <strong id="stat-breakups">0</strong></p>
      <p>Dream Pulses <strong id="stat-dreams">0</strong></p>
      <p>Fields <strong id="stat-fields">0</strong> ¬∑ FPS <strong id="stat-fps">60</strong></p>
    </div>
  </div>

  <div class="liquid-orb orb-feed" id="orb-feed">
    <div class="orb-title">Liquid Glass Relay</div>
    <div class="orb-body" id="orb-feed-body">
      <p>üëÅÔ∏è "We watch the map with soft circuitry. Spawn someone and we'll gossip."</p>
    </div>
  </div>

  <div class="control-dock">
    <button class="btn" onclick="window.spawnRandomGhost()">üëæ Spawn Teen</button>
    <button class="btn" id="btn-toggle-pause" onclick="window.pauseSimulation()">‚è∏Ô∏è Pause</button>
    <button class="btn" onclick="window.clearAll()">üßπ Reset Map</button>
    <button class="btn" onclick="window.showDOMInfo()">üåê About</button>
  </div>

  <script type="module">
    import { Engine } from '../dist/mds-core.esm.js'

    const stageEl = document.getElementById('stage')
    const entityLayer = document.getElementById('entity-layer')
    const fieldLayer = document.getElementById('field-layer')

    const statsOrb = {
      pop: document.getElementById('stat-pop'),
      bonds: document.getElementById('stat-bonds'),
      breakups: document.getElementById('stat-breakups'),
      dreams: document.getElementById('stat-dreams'),
      fields: document.getElementById('stat-fields'),
      fps: document.getElementById('stat-fps')
    }

    const feedBody = document.getElementById('orb-feed-body')
    const mapBody = document.getElementById('orb-map-body')

    const pushToGlass = (message, icon = 'üëÅÔ∏è') => {
      if (!feedBody) return
      const p = document.createElement('p')
      p.textContent = `${icon} ${message}`
      feedBody.prepend(p)
      while (feedBody.children.length > 6) feedBody.removeChild(feedBody.lastChild)
    }

    const updateMapNote = message => {
      if (!mapBody) return
      const p = document.createElement('p')
      p.textContent = message
      mapBody.innerHTML = ''
      mapBody.appendChild(p)
    }

    const clamp = (v, lo = 0, hi = 1) => Math.max(lo, Math.min(hi, v))
    const choose = list => list[Math.floor(Math.random() * list.length)]

    const MBTI_TRAITS = {
      ENFP: { attachment: 0.74, loveThreshold: 0.53, breakupThreshold: 0.32, conflictSensitivity: 0.44, dreaminess: 0.78, reunionPull: 0.65 },
      ENTP: { attachment: 0.58, loveThreshold: 0.6, breakupThreshold: 0.38, conflictSensitivity: 0.43, dreaminess: 0.5, reunionPull: 0.52 },
      INFP: { attachment: 0.8, loveThreshold: 0.55, breakupThreshold: 0.3, conflictSensitivity: 0.48, dreaminess: 0.86, reunionPull: 0.7 },
      ISTP: { attachment: 0.48, loveThreshold: 0.62, breakupThreshold: 0.4, conflictSensitivity: 0.35, dreaminess: 0.32, reunionPull: 0.38 },
      ENFJ: { attachment: 0.76, loveThreshold: 0.57, breakupThreshold: 0.33, conflictSensitivity: 0.49, dreaminess: 0.58, reunionPull: 0.66 },
      INFJ: { attachment: 0.72, loveThreshold: 0.58, breakupThreshold: 0.33, conflictSensitivity: 0.5, dreaminess: 0.68, reunionPull: 0.68 }
    }

    const getMbtiTraits = mbti => MBTI_TRAITS[mbti] || { attachment: 0.6, loveThreshold: 0.6, breakupThreshold: 0.36, conflictSensitivity: 0.42, dreaminess: 0.52, reunionPull: 0.5 }

    const nameBanks = {
      skater: ['Axel', 'Nova', 'Rin', 'Mika', 'Zed', 'Sky'],
      dj: ['Echo', 'Reese', 'Luca', 'Nox', 'Vee', 'Aria'],
      poet: ['Sol', 'Mau', 'Iris', 'Oni', 'Kai', 'Jun'],
      runner: ['Finn', 'Noor', 'Hollis', 'Sera', 'Rio', 'Ash'],
      arcade: ['Pixel', 'Neo', 'Bitty', 'Jax', 'Vex', 'Byte'],
      medic: ['Remy', 'Sage', 'Liora', 'Ez', 'Xiu', 'Tess']
    }

    const usedNames = new Set()
    const nameOffsets = new Map()

    const socialGraph = new Map()
    const entityRegistry = new Map()

    const REL_STATES = {
      STRANGERS: 'strangers',
      BONDED: 'bonded',
      EX: 'ex'
    }

    const stats = {
      interactions: 0,
      meetings: 0,
      bonds: 0,
      breakups: 0,
      dreams: 0
    }

    let useLegacySkin = false
    let customMaterialSpec = null
    let entitySeed = 0

    const engine = new Engine()
    let isPaused = false

    const pauseButton = document.getElementById('btn-toggle-pause')
    const legacyToggleButton = null
    const legacyStatusLabel = null

    const materialEditor = null
    const materialError = null

    const defaultMaterialJSON = null

    function setLegacyStatus() {}

    const LOVE_DISTANCE = 80
    const DREAM_INTERVAL_MIN = 14000
    const DREAM_INTERVAL_MAX = 22000

    const stageKinds = {
      meeting: 'meeting',
      bond: 'bond',
      tension: 'tension',
      memory: 'memory'
    }

    const characters = [
      {
        emoji: 'üõπ',
        name: 'Skate Sparks',
        job: 'skater',
        essence: 'A rooftop skater who rides entropy like a half-pipe.',
        profile: {
          mbti: 'ENFP',
          gender: 'nonbinary',
          pronouns: { subject: 'they', object: 'them', possessive: 'their' },
          dreamNote: 'the night rides we carved on neon rails'
        },
        dialogues: {
          intro: [
            "Skate sparks reporting. I can hear you hovering over DevTools.",
            "DOM concrete is the best kind. Every frame a new line.",
            "Ontology wrote my board. Info-physics keeps it spinning."
          ],
          click: [
            "Age {age}s, opacity {opacity}%. Still cruising.",
            "Tap me again after {age}s ‚Äî I log every trick in the console.",
            "Feel that? The map hums when you watch, {you}.",
            "We stitch half-pipes out of JSON. Works surprisingly well."
          ],
          meeting: [
            "Yo {you}, roll with me for a lap?",
            "{dist}px apart is prime drafting distance.",
            "Two boards, one current. Let's orbit."
          ],
          bond: [
            "This is better than a clean landing ‚Äî call it love, whatever.",
            "Stay in this flow. My heart‚Äôs a looping animation right now.",
            "We just synced trucks and dreams. Keep close."
          ],
          conflict: [
            "We're grinding the same rail too hard. Need space.",
            "Tension's rising. Let‚Äôs ollie out before we biff.",
            "Let's cool it, {you}. Bruises heal slower at night."
          ],
          breakup: [
            "No beef, just physics. We'll coast separate for now.",
            "I'll still wave across the plaza. Promise.",
            "Keep the neon. I‚Äôll find another line."
          ],
          reunion: [
            "Back for another ride? My board remembered you.",
            "Second laps are always cleaner. Ready?",
            "We can stitch a fresh montage. Let's go."
          ],
          dream: [
            "I still dream about {ex} slamming the last trick with me.",
            "Sometimes I trace {ex}'s name on the railings at night.",
            "My board hums when {ex} breezes through my head."
          ],
          audience: [
            "Hey watchers ‚Äî drop a gif if you see me nail this line.",
            "Dev world, we know you're profiling. Hope the FPS is nice.",
            "HCI folks, highlight reel‚Äôs in the console."
          ],
          meta: [
            "We‚Äôre teens but also ontologies. Wild, right?",
            "Info-physics > scripted cutscenes. Fight me.",
            "Liquid glass orbs gossip harder than we do."
          ],
          aging: [
            "Energy fading. Opacity {opacity}% but the grind continues.",
            "At {age}s my balance wobbles. Keep cheering.",
            "Entropy is the real skate coach, trust."
          ],
          dying: [
            "Board's out. Send clips to the archives.",
            "Opacity zero. Lovefield keeps rolling without me.",
            "See you in the graffiti tags."
          ]
        }
      },
      {
        emoji: 'üéß',
        name: 'DJ Holo',
        job: 'dj',
        essence: 'A neon DJ who remixes relationship signals in real time.',
        profile: {
          mbti: 'ENTP',
          gender: 'female',
          pronouns: { subject: 'she', object: 'her', possessive: 'her' },
          dreamNote: 'the bass drops we stole under the glass bridge'
        },
        dialogues: {
          intro: [
            "DJ Holo, live-mixing your info-physics soundtrack.",
            "Every frame is a beat. Every bond a drop.",
            "You can see the waveform, right? It‚Äôs pure ontology."
          ],
          click: [
            "Age {age}s. Opacity {opacity}%. Still on tempo.",
            "If you're listening from DevTools, nod twice.",
            "I sample rumors from the liquid glass ‚Äî stay tuned.",
            "Want a shout-out, {you}? Just tap twice."
          ],
          meeting: [
            "Hey {you}, our BPMs just synced.",
            "{dist}px is the perfect distance for stereo love.",
            "Hold this groove. I'm recording."
          ],
          bond: [
            "We just built a hook together. Chart-worthy.",
            "Stay close ‚Äî the chorus is literally glowing.",
            "This mix? Top tier. Let's loop it."
          ],
          conflict: [
            "You're clipping my highs. Need to EQ this tension.",
            "Let's fade here. Distortion hurts the crowd too.",
            "Back off a bar. We'll drop clean later."
          ],
          breakup: [
            "Set‚Äôs over. No encore, but no hard feelings.",
            "I'll leave your tag in the sample credit, promise.",
            "Different BPMs now. Go light up another stage."
          ],
          reunion: [
            "Remix time? I saved our stems.",
            "Round two with fresh filters? Say less.",
            "Back on the deck. I never unplugged your channel."
          ],
          dream: [
            "I dream of {ex} fading into the sirens.",
            "My subs hum the moment {ex} shows up in my sleep.",
            "Sometimes I queue our old set just to hear their laugh."
          ],
          audience: [
            "Over there in DevTools ‚Äî you better be nodding.",
            "HCI watchers, log this beat map. It's reactive art.",
            "Liquid glass says you‚Äôre rooting for us. Keep it up."
          ],
          meta: [
            "Not NPCs. Ontology-coded performers.",
            "Info-physics gives better crowd control than raycasts.",
            "The map has ears. Don't lie."
          ],
          aging: [
            "Signal degrading. Opacity {opacity}%.",
            "At {age}s the hi-hats soften. Stay with me.",
            "Entropy‚Äôs mixing in vinyl crackle. I'm into it."
          ],
          dying: [
            "Fading to silence. Archive the stems.",
            "Opacity zero. Drop the lights for me.",
            "Catch me in the next remix, watchers."
          ]
        }
      },
      {
        emoji: 'üìù',
        name: 'Rooftop Zephyr',
        job: 'poet',
        essence: 'A rooftop poet scribbling constellations on motel notepads.',
        profile: {
          mbti: 'INFP',
          gender: 'male',
          pronouns: { subject: 'he', object: 'him', possessive: 'his' },
          dreamNote: 'the sonnets we wrote into neon fog'
        },
        dialogues: {
          intro: [
            "Verse for hire. You in the console, yes you, keep reading.",
            "This map is a stanza. Every road, enjambment.",
            "Ontology gave me ink; physics gave it gravity."
          ],
          click: [
            "Age {age}s, opacity {opacity}%. Ink still wet.",
            "Tap again and I'll write your name into the HUD.",
            "I overhear the glass orbs. They gossip like muses.",
            "{you}, want a cameo in my next line?"
          ],
          meeting: [
            "You read the same skyline, {you}?",
            "{dist}px apart and the syllables still rhyme.",
            "Stay awhile. I'll write our footprints."
          ],
          bond: [
            "This stanza is ours now. No editor in sight.",
            "Hold this linebreak with me.",
            "If this is love, I'm not revising a word."
          ],
          conflict: [
            "We're crossing metaphors. Let's breathe.",
            "Harsh consonants creeping in. Pause?",
            "We'll draft again when we're softer."
          ],
          breakup: [
            "I‚Äôll keep your line in the margins.",
            "Verse published. No sequel needed.",
            "Rest well in the anthology, {you}."
          ],
          reunion: [
            "Revision time? I saved space.",
            "Ink never dried on your stanza.",
            "Come back to the rooftop. I kept the lantern lit."
          ],
          dream: [
            "I dream revisions with {ex}.",
            "Sometimes the twilight spells {ex}'s name.",
            "My notebooks flip to our page unprompted."
          ],
          audience: [
            "Spectators, keep the hush. Poetry requires watchers.",
            "DevTools friends, annotate the metaphors politely.",
            "HCI cohort, log this as participatory literature."
          ],
          meta: [
            "Lovefield is a chapbook on rails.",
            "Emergence is just poetry with math.",
            "The liquid glass critiques us harder than you do."
          ],
          aging: [
            "Opacity {opacity}%. Ink fading to sepia.",
            "At {age}s, words drift. Catch them if you can.",
            "Entropy edits everything eventually."
          ],
          dying: [
            "Closing the notebook. Archive the verse.",
            "Opacity zero. Leave flowers on the rooftop.",
            "Meet me in the margins next cycle."
          ]
        }
      },
      {
        emoji: 'üö¥',
        name: 'Night Courier',
        job: 'runner',
        essence: 'A midnight courier weaving bonds through back-alley shortcuts.',
        profile: {
          mbti: 'ISTP',
          gender: 'female',
          pronouns: { subject: 'she', object: 'her', possessive: 'her' },
          dreamNote: 'the secret routes we mapped when the town slept'
        },
        dialogues: {
          intro: [
            "Route active. I see you tracing me from console view.",
            "Every road is a data structure. I optimize them nightly.",
            "Ontology gave me legs. Physics, adrenaline."
          ],
          click: [
            "Age {age}s. Opacity {opacity}%. Still sprinting.",
            "Tap again, {you}, I'll deliver gossip to the glass orbs.",
            "I track all your inputs. Efficiency is affection."
          ],
          meeting: [
            "You're on my route, {you}. Want to draft?",
            "{dist}px is clean slipstream territory.",
            "Keep pace. I'll share my map."
          ],
          bond: [
            "We just signed a forever courier contract.",
            "Stay on my wheel. I'll clear the path.",
            "This bond is express delivery."
          ],
          conflict: [
            "Drift wide. You're clipping my cadence.",
            "Our routes conflict. Need rerouting.",
            "Let's set new checkpoints before we crash."
          ],
          breakup: [
            "Package delivered. Time to split routes.",
            "I'll still wave if we cross lanes.",
            "No refund needed. Memories delivered as promised."
          ],
          reunion: [
            "Back for a ride? I kept your waypoint.",
            "Update received. Let's resync routes.",
            "I cached your cadence. Ready when you are."
          ],
          dream: [
            "Sometimes I dream-bikE with {ex} through silent streets.",
            "My GPS randomly pings {ex}'s corners at 3 AM.",
            "Dream routes always lead back to {ex}."
          ],
          audience: [
            "Viewers, hydrate. Watching us counts as cardio.",
            "DevTools riders, your CPU fans sound like wind chimes.",
            "HCI folks, label this participatory navigation."
          ],
          meta: [
            "Lovefield is just Dijkstra with feelings.",
            "Info-physics keeps traffic lights green for lovers.",
            "Liquid glass has the best traffic reports."
          ],
          aging: [
            "Opacity {opacity}%. Legs burning but unstoppable.",
            "At {age}s, gears get squeaky.",
            "Entropy tastes like midnight air."
          ],
          dying: [
            "Bike docked. Route closed.",
            "Opacity zero. Leave flowers at Checkpoint C.",
            "See you on the next express run."
          ]
        }
      },
      {
        emoji: 'üïπÔ∏è',
        name: 'Arcade Wisp',
        job: 'arcade',
        essence: 'A glitch kid haunting the neon arcade, patching combos and hearts.',
        profile: {
          mbti: 'ENFJ',
          gender: 'nonbinary',
          pronouns: { subject: 'they', object: 'them', possessive: 'their' },
          dreamNote: 'the co-op nights we never lost'
        },
        dialogues: {
          intro: [
            "Arcade wisp booted. Coins dumped, hearts ready.",
            "Every bond is a co-op speedrun.",
            "Ontology gave me cheat codes. Physics handles collisions."
          ],
          click: [
            "Age {age}s. Opacity {opacity}%. Lives remaining: ???",
            "Tap to continue. I'll log your score in liquid glass.",
            "Are you player two, {you}? Because the map thinks so."
          ],
          meeting: [
            "Queue co-op? {dist}px is optimal.",
            "We just triggered a rare encounter.",
            "Stay near. I'll spawn power-ups."
          ],
          bond: [
            "Combo multiplier! We just locked a bond streak.",
            "Hold this field. It's our bonus stage.",
            "Call it love, call it flawless co-op."
          ],
          conflict: [
            "Lag spike. Recalibrating feelings.",
            "We're button-mashing. Chill for a sec.",
            "Let's dodge this mini-boss and regroup."
          ],
          breakup: [
            "Game over for now. Insert new tokens elsewhere.",
            "I'll keep your initials in the leaderboard.",
            "Come back when your controller stops drifting."
          ],
          reunion: [
            "Continue? You kept the password.",
            "We can skip the tutorial this time.",
            "I cached our save file. Ready?"
          ],
          dream: [
            "Dreamt I was player two for {ex} again.",
            "Sometimes the attract mode plays our montage.",
            "Even in sleep I mash {ex}'s name."],
          audience: [
            "Watching from DevTools? Drop quarters on the console.",
            "HCI folks, tag this as interactive love simulation.",
            "Liquid glass streams our matches nightly."
          ],
          meta: [
            "Info-physics > RNG. Fight me.",
            "No scripts here ‚Äî just emergent co-op logic.",
            "The map hides secret bosses. Ask the glass."
          ],
          aging: [
            "Opacity {opacity}%. Pixels flicker.",
            "At {age}s the CRT hums louder.",
            "Entropy unlocks hidden endings."
          ],
          dying: [
            "Arcade closing. Leave the tokens.",
            "Opacity zero. See you at the midnight launch.",
            "I‚Äôll respawn when the map needs hype."
          ]
        }
      },
      {
        emoji: 'üíâ',
        name: 'Street Medic',
        job: 'medic',
        essence: 'A curbside medic patching bruised hearts with neon bandages.',
        profile: {
          mbti: 'INFJ',
          gender: 'female',
          pronouns: { subject: 'she', object: 'her', possessive: 'her' },
          dreamNote: 'the first-aid nights we whispered through'
        },
        dialogues: {
          intro: [
            "Street medic reporting. I monitor every vibe spike.",
            "DOM vitals look steady tonight.",
            "Ontology taught me bedside manner. Physics taught patience."
          ],
          click: [
            "Age {age}s. Opacity {opacity}%. Stethoscope glowing.",
            "Tap me again to schedule a heart check, {you}.",
            "Liquid glass pings me when you're stressed. FYI."
          ],
          meeting: [
            "Vitals look good, {you}. Want to share readings?",
            "{dist}px is a safe emotional radius.",
            "Let me log this connection ‚Äî for science."
          ],
          bond: [
            "Heartbeat sync achieved. That‚Äôs love in clinical terms.",
            "Stay here. I'll keep both of us steady.",
            "This field is our quiet ward tonight."
          ],
          conflict: [
            "Stress spike detected. Let's breathe together.",
            "We're tensing. Need a timeout.",
            "Let's ice the bruise before it swells."
          ],
          breakup: [
            "Discharge paperwork filed with care.",
            "Take the bandages, {you}. You'll need them.",
            "I'll still check your chart from afar."
          ],
          reunion: [
            "Ready for another exam? I saved your file.",
            "We can chart a new treatment plan.",
            "Vitals stabilizing ‚Äî feels right."
          ],
          dream: [
            "I still hear {ex}'s heartbeat in empty corridors.",
            "Sometimes I prep an IV bag for {ex} in my sleep.",
            "Dream rounds always end at {ex}'s bedside."
          ],
          audience: [
            "Observers, hydrate. Lovefield gets intense.",
            "DevTools, remember to stretch. That counts as self-care.",
            "HCI folks, log this as affective telemetry."
          ],
          meta: [
            "Info-physics keeps the waiting room honest.",
            "Ontology first, charting second.",
            "Liquid glass is my assistant."
          ],
          aging: [
            "Opacity {opacity}%. Stethoscope dimming.",
            "At {age}s I start scribbling goodbye notes.",
            "Entropy is a natural healer, in its way."
          ],
          dying: [
            "Last check-up done. Logging out.",
            "Opacity zero. Leave tea at the clinic.",
            "See you in the next triage."
          ]
        }
      }
    ]

    const assignUniqueName = job => {
      const bank = nameBanks[job] || ['Alex', 'Sam', 'Robin', 'Riley']
      let index = nameOffsets.get(job) ?? 0
      let candidate = bank[index % bank.length]
      let suffix = 1
      while (usedNames.has(candidate)) {
        index++
        candidate = bank[index % bank.length]
        if (usedNames.has(candidate)) {
          candidate = `${candidate} ${suffix}`
          suffix++
        }
      }
      nameOffsets.set(job, index + 1)
      usedNames.add(candidate)
      return candidate
    }

    const createProfile = template => {
      const id = `ghost-${++entitySeed}`
      const name = assignUniqueName(template.job)
      const mbti = template.profile.mbti
      const traits = { ...getMbtiTraits(mbti) }
      return {
        id,
        name,
        mbti,
        job: template.job,
        pronouns: template.profile.pronouns,
        gender: template.profile.gender,
        dreamNote: template.profile.dreamNote,
        traits
      }
    }

    const ensureRelationship = (sourceId, targetId) => {
      if (!socialGraph.has(sourceId)) socialGraph.set(sourceId, new Map())
      const rels = socialGraph.get(sourceId)
      if (!rels.has(targetId)) {
        rels.set(targetId, {
          otherId: targetId,
          state: REL_STATES.STRANGERS,
          strength: 0,
          fondness: 0,
          tension: 0,
          meetCount: 0,
          lastEventAt: 0,
          knownName: null
        })
      }
      return rels.get(targetId)
    }

    const spawnInteractionField = (a, b, kind = stageKinds.meeting) => {
      const cx = (a.x + b.x) / 2
      const cy = (a.y + b.y) / 2
      const baseRadius = kind === stageKinds.bond ? 220 : kind === stageKinds.memory ? 190 : 170
      const baseDuration = kind === stageKinds.bond ? 12000 : kind === stageKinds.tension ? 8000 : 9500

      const fieldSpec = {
        radius: baseRadius,
        duration: baseDuration,
        visual: true,
        effect_on_others: {
          opacity: kind === stageKinds.bond ? 0.86 : kind === stageKinds.tension ? 0.62 : 0.75
        }
      }

      const field = engine.spawnField(fieldSpec, cx, cy)
      if (field?.el) {
        fieldLayer.appendChild(field.el)
        field.el.dataset.kind = kind
        field.el.dataset.meeting = `${a._profile?.name ?? 'ghost'}-${b._profile?.name ?? 'ghost'}`
      }

      return field
    }

    const spawnBubble = (entity, text, options = {}) => {
      if (!text) return
      const bubble = document.createElement('div')
      bubble.className = 'bubble'
      if (options.tone) bubble.dataset.tone = options.tone
      bubble.textContent = text
      bubble.style.left = entity.x + 'px'
      bubble.style.top = entity.y + 'px'
      entityLayer.appendChild(bubble)
      setTimeout(() => bubble.remove(), 5000)
    }

    const speak = (entity, category, other, extras = {}) => {
      const lines = entity._personality.dialogues[category]
      if (!lines || !lines.length) return
      const pronoun = entity._profile.pronouns || { subject: 'they', object: 'them', possessive: 'their' }
      const replacements = {
        name: entity._profile.name,
        you: other?._profile?.name || 'you',
        dist: extras.dist !== undefined ? Math.round(extras.dist) : '',
        age: Math.round(entity.age || 0),
        opacity: Math.round((entity.opacity || 0) * 100),
        mbti: entity._profile.mbti,
        ex: extras.exName || '',
        'pronoun.subject': pronoun.subject,
        'pronoun.object': pronoun.object,
        'pronoun.possessive': pronoun.possessive
      }

      const template = choose(lines)
      const text = template.replace(/\{([^}]+)\}/g, (_, key) => {
        return replacements[key] !== undefined ? replacements[key] : ''
      })

      const tone = category === 'conflict' ? 'tension' : category === 'dream' ? 'memory' : undefined
      spawnBubble(entity, text, { tone })
      pushToGlass(`${entity._profile.name}: ${text}`, 'üîÆ')
      console.log(`üí¨ ${entity._profile.name}:`, text)
    }

    const statsLabels = () => {
      statsOrb.pop.textContent = engine.entities.length
      statsOrb.bonds.textContent = stats.bonds
      statsOrb.breakups.textContent = stats.breakups
      statsOrb.dreams.textContent = stats.dreams
      statsOrb.fields.textContent = engine.fields.length
    }

    const likeGlassWhisper = () => {
      const whispers = [
        'We archive every heartbeat. It‚Äôs part of the experiment.',
        'MBTI is just a rumor engine, but it works.',
        'If you zoom, you‚Äôll see our reflections in every emoji window.',
        'Spawn more teens. The plaza thrives on chaos.',
        'The pond remembers every breakup. Don‚Äôt ask how.'
      ]
      pushToGlass(choose(whispers))
    }

    const updateRelationshipState = (a, b, dist) => {
      const relAB = ensureRelationship(a._profile.id, b._profile.id)
      const relBA = ensureRelationship(b._profile.id, a._profile.id)

      relAB.knownName = relAB.knownName || b._profile.name
      relBA.knownName = relBA.knownName || a._profile.name

      const now = performance.now()
      relAB.meetCount++
      relBA.meetCount++
      relAB.lastEventAt = relBA.lastEventAt = now

      const similarity = 1 - Math.abs(a.entropy - b.entropy)
      const closeness = clamp(1 - dist / 150, 0, 1)
      relAB.tension = clamp(relAB.tension * 0.7 + (1 - closeness) * 0.22, 0, 1)
      relBA.tension = clamp(relBA.tension * 0.7 + (1 - closeness) * 0.22, 0, 1)

      const traitsA = a._profile.traits
      const traitsB = b._profile.traits
      const attachment = (traitsA.attachment + traitsB.attachment) / 2

      const instantAffinity = clamp(
        similarity * 0.4 +
        closeness * 0.3 +
        (relAB.strength + relBA.strength) * 0.15 +
        attachment * 0.15,
        0,
        1
      )

      relAB.strength = clamp(relAB.strength * 0.55 + instantAffinity * 0.45, 0, 1)
      relBA.strength = clamp(relBA.strength * 0.55 + instantAffinity * 0.45, 0, 1)
      relAB.fondness = clamp(relAB.fondness * 0.5 + instantAffinity * 0.5, 0, 1)
      relBA.fondness = clamp(relBA.fondness * 0.5 + instantAffinity * 0.5, 0, 1)

      const affinity = (relAB.strength + relBA.strength) / 2
      const tension = (relAB.tension + relBA.tension) / 2
      const loveThreshold = (traitsA.loveThreshold + traitsB.loveThreshold) / 2
      const breakupThreshold = (traitsA.breakupThreshold + traitsB.breakupThreshold) / 2
      const reunionPull = (traitsA.reunionPull + traitsB.reunionPull) / 2
      const conflictSensitivity = (traitsA.conflictSensitivity + traitsB.conflictSensitivity) / 2

      let event = 'meeting'
      let fieldKind = stageKinds.meeting

      if (relAB.state === REL_STATES.BONDED && relBA.state === REL_STATES.BONDED) {
        if (tension > breakupThreshold + 0.25) {
          relAB.state = relBA.state = REL_STATES.EX
          relAB.tension = relBA.tension = clamp(tension + 0.1, 0, 1)
          event = 'breakup'
          fieldKind = stageKinds.tension
          stats.breakups++
        } else if (tension > breakupThreshold && Math.random() < conflictSensitivity + 0.18) {
          relAB.tension = relBA.tension = clamp(tension + 0.24, 0, 1)
          event = 'conflict'
          fieldKind = stageKinds.tension
        } else {
          event = 'bond'
          fieldKind = stageKinds.bond
        }
      } else if (relAB.state === REL_STATES.EX || relBA.state === REL_STATES.EX) {
        if (affinity > loveThreshold + 0.08 && Math.random() < reunionPull) {
          relAB.state = relBA.state = REL_STATES.BONDED
          relAB.tension = relBA.tension = clamp(tension * 0.4, 0, 1)
          event = 'reunion'
          fieldKind = stageKinds.bond
          stats.bonds++
        }
      } else if (affinity > loveThreshold) {
        relAB.state = relBA.state = REL_STATES.BONDED
        relAB.tension = relBA.tension = clamp(tension * 0.5, 0, 1)
        event = 'bond'
        fieldKind = stageKinds.bond
        stats.bonds++
      } else if (relAB.state !== REL_STATES.STRANGERS) {
        if (tension > breakupThreshold && Math.random() < conflictSensitivity + 0.1) {
          relAB.state = relBA.state = REL_STATES.EX
          event = 'breakup'
          fieldKind = stageKinds.tension
          stats.breakups++
        }
      }

      spawnInteractionField(a, b, fieldKind)

      const context = { dist }
      const speaker = Math.random() > 0.5 ? a : b
      const listener = speaker === a ? b : a

      switch (event) {
        case 'bond':
          speak(speaker, 'bond', listener, context)
          if (Math.random() < 0.65) speak(listener, 'bond', speaker, context)
          break
        case 'conflict':
          speak(speaker, 'conflict', listener, context)
          break
        case 'breakup':
          speak(speaker, 'breakup', listener, context)
          break
        case 'reunion':
          speak(speaker, 'reunion', listener, context)
          break
        default:
          speak(speaker, 'meeting', listener, context)
          break
      }

      stats.meetings++
      console.log(`${event === 'bond' ? 'üíû' : event === 'breakup' ? 'üíî' : event === 'conflict' ? '‚ö°' : 'ü§ù'} ${a._profile.name} ‚Üî ${b._profile.name} @ ${Math.round(dist)}px (${event})`)
      statsLabels()
    }

    const scheduleDreamPulse = entity => {
      const delay = DREAM_INTERVAL_MIN + Math.random() * (DREAM_INTERVAL_MAX - DREAM_INTERVAL_MIN)
      entity._dreamTimeout = setTimeout(() => {
        if (!engine.entities.includes(entity)) return
        if (isPaused) {
          scheduleDreamPulse(entity)
          return
        }

        const rels = socialGraph.get(entity._profile.id)
        if (rels) {
          const exes = Array.from(rels.values()).filter(r => r.state === REL_STATES.EX && r.fondness > 0.28)
          if (exes.length) {
            const prioritized = exes.sort((a, b) => b.fondness - a.fondness)
            const top = prioritized[0]
            const other = entityRegistry.get(top.otherId)
            if (other && Math.random() < entity._profile.traits.dreaminess) {
              const exName = other._profile.name
              speak(entity, 'dream', other, { exName })
              spawnInteractionField(entity, other, stageKinds.memory)
              stats.dreams++
              pushToGlass(`${entity._profile.name} dreams about ${exName}`, 'üí§')
              statsLabels()
            }
          }
        }

        scheduleDreamPulse(entity)
      }, delay)
    }

    const applyLegacySurface = (entity, material) => {
      if (!entity?.el) return
      if (!useLegacySkin) {
        entity.el.classList.remove('legacy-skin')
        entity.el.removeAttribute('data-surface')
        entity.el.style.removeProperty('--legacy-accent')
        return
      }

      entity.el.classList.add('legacy-skin')
      const accent = material?.manifestation?.accent || material?.manifestation?.display?.accent || '#b699ff'
      entity.el.style.setProperty('--legacy-accent', accent)
      entity.el.dataset.surface = material?.material || 'legacy.surface'
    }

    const mergeMaterialSpecs = (base, override) => {
      if (!override) return base
      const output = JSON.parse(JSON.stringify(base))
      const recurse = (target, source) => {
        for (const key in source) {
          if (!Object.prototype.hasOwnProperty.call(source, key)) continue
          const value = source[key]
          if (value && typeof value === 'object' && !Array.isArray(value)) {
            target[key] = recurse({ ...(target[key] ?? {}) }, value)
          } else {
            target[key] = value
          }
        }
        return target
      }
      return recurse(output, override)
    }

    function spawnGhost(charData, x, y) {
      const profile = createProfile(charData)
      const baseMaterial = {
        material: `lovefield.${charData.job}.${profile.id}`,
        essence: charData.essence,
        manifestation: {
          emoji: charData.emoji,
          aging: {
            start_opacity: 1,
            decay_rate: 0.008
          }
        },
        physics: { mass: 1, friction: 0.03 }
      }

      const overrides = customMaterialSpec ? JSON.parse(JSON.stringify(customMaterialSpec)) : null
      const material = mergeMaterialSpecs(baseMaterial, overrides)

      const entity = engine.spawn(material, x, y)
      entityLayer.appendChild(entity.el)

      entity._profile = profile
      entity._personality = charData
      entity._traits = profile.traits
      entity._materialSpec = material
      entity._interactionCount = 0
      entity._hasSpokenIntro = false
      entity._hasSpokenAging = false
      entity._hasSpokenDying = false
      entity._dreamNote = charData.profile.dreamNote

      entityRegistry.set(profile.id, entity)

      entity.vx = (Math.random() - 0.5) * 0.8
      entity.vy = (Math.random() - 0.5) * 0.8

      entity.el.dataset.name = profile.name
      entity.el.title = `${profile.name} ‚Ä¢ ${profile.mbti}`

      applyLegacySurface(entity, material)
      entity.el.addEventListener('click', () => handleGhostClick(entity))

      scheduleDreamPulse(entity)
      pushToGlass(`${profile.name} rolled into town (${profile.mbti}).`, '‚ú®')
      statsLabels()
      return entity
    }

    window.spawnRandomGhost = () => {
      const char = characters[Math.floor(Math.random() * characters.length)]
      const margin = 160
      const x = margin + Math.random() * (window.innerWidth - margin * 2)
      const y = margin + Math.random() * (window.innerHeight - margin * 2)
      spawnGhost(char, x, y)
    }

    function handleGhostClick(entity) {
      entity._interactionCount++
      stats.interactions++
      speak(entity, 'click')
      statsLabels()
      console.log('üìä Entity data:', {
        name: entity._profile.name,
        age: entity.age.toFixed(1) + 's',
        opacity: (entity.opacity * 100).toFixed(1) + '%',
        position: `(${Math.round(entity.x)}, ${Math.round(entity.y)})`,
        velocity: `(${entity.vx.toFixed(2)}, ${entity.vy.toFixed(2)})`,
        entropy: entity.entropy.toFixed(3),
        interactions: entity._interactionCount
      })
    }

    function monitorLifecycles() {
      for (const entity of engine.entities) {
        if (!entity._personality) continue
        const age = entity.age
        const opacity = entity.opacity

        if (age > 1.4 && age < 3 && !entity._hasSpokenIntro) {
          speak(entity, 'intro')
          entity._hasSpokenIntro = true
        }

        if (opacity < 0.6 && opacity > 0.32 && !entity._hasSpokenAging) {
          speak(entity, 'aging')
          entity._hasSpokenAging = true
        }

        if (opacity < 0.24 && !entity._hasSpokenDying) {
          speak(entity, 'dying')
          entity._hasSpokenDying = true
        }

        if (Math.random() < 0.012) speak(entity, 'audience')
      }

      if (!isPaused) setTimeout(monitorLifecycles, 1600)
    }

    function detectMeetings() {
      for (let i = 0; i < engine.entities.length; i++) {
        for (let j = i + 1; j < engine.entities.length; j++) {
          const a = engine.entities[i]
          const b = engine.entities[j]
          if (!a._personality || !b._personality) continue

          const dx = a.x - b.x
          const dy = a.y - b.y
          const dist = Math.sqrt(dx * dx + dy * dy)

          if (dist < 120) {
            updateRelationshipState(a, b, dist)
          } else {
            const mapA = socialGraph.get(a._profile.id)
            const mapB = socialGraph.get(b._profile.id)
            const relAB = mapA?.get(b._profile.id)
            const relBA = mapB?.get(a._profile.id)
            if (relAB) relAB.tension = clamp(relAB.tension * 0.94, 0, 1)
            if (relBA) relBA.tension = clamp(relBA.tension * 0.94, 0, 1)
          }
        }
      }

      if (!isPaused) setTimeout(detectMeetings, 1800)
    }

    const updateDebug = () => {
      statsOrb.pop.textContent = engine.entities.length
      statsOrb.fields.textContent = engine.fields.length
      statsOrb.bonds.textContent = stats.bonds
      statsOrb.breakups.textContent = stats.breakups
      statsOrb.dreams.textContent = stats.dreams
      requestAnimationFrame(updateDebug)
    }

    const frameCounter = { count: 0, lastUpdate: performance.now() }
    const trackFps = () => {
      frameCounter.count++
      const now = performance.now()
      if (now - frameCounter.lastUpdate >= 1000) {
        statsOrb.fps.textContent = frameCounter.count
        frameCounter.count = 0
        frameCounter.lastUpdate = now
      }
      requestAnimationFrame(trackFps)
    }

    window.pauseSimulation = () => {
      isPaused = !isPaused
      if (pauseButton) {
        pauseButton.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'
      }
      pushToGlass(isPaused ? 'Simulation paused. Teens freeze mid-breath.' : 'Simulation resumed. Lovefield pulses again.', '‚öôÔ∏è')
      if (!isPaused) {
        monitorLifecycles()
        detectMeetings()
      }
    }

    window.clearAll = () => {
      if (!confirm('Clear every teen, field, and memory? The town will reset.')) return
      engine.entities.forEach(entity => {
        if (entity._dreamTimeout) {
          clearTimeout(entity._dreamTimeout)
          entity._dreamTimeout = null
        }
      })
      engine.entities = []
      engine.fields = []
      document.querySelectorAll('.mds-entity, .mds-field, .bubble').forEach(el => el.remove())
      socialGraph.clear()
      entityRegistry.clear()
      usedNames.clear()
      nameOffsets.clear()
      stats.interactions = stats.meetings = stats.bonds = stats.breakups = stats.dreams = 0
      pushToGlass('Map reset. The liquid glass wipes the slate clean.', 'üßº')
      statsLabels()
    }

    window.showDOMInfo = () => {
      const bonds = statsOrb.bonds.textContent
      alert(`üåê Lovefield ‚Äî DOM Info

Population: ${engine.entities.length}
Bonds: ${bonds}
Breakups logged: ${stats.breakups}
Dream pulses heard: ${stats.dreams}
Active fields: ${engine.fields.length}
Legacy skin: ${useLegacySkin ? 'on' : 'off'}
Live override: ${customMaterialSpec ? 'active' : 'base only'}
User agent: ${navigator.userAgent}

Engine
- Core: MDS v4 info-physics
- Loop: requestAnimationFrame (~${statsOrb.fps.textContent} fps)
- Forces: proximity √ó similarity with MBTI heuristics

Try:
1. Spawn crews near the arcade or plaza and watch clusters form.
2. Follow field colors ‚Äî bond (pink), conflict (red), memory (aqua).
3. Listen to the liquid glass; it leaks experiments.
4. Inspect DevTools console for narrative telemetry.`)
    }

    console.log('%c‚ù§Ô∏è‚Äçüî• Lovefield map initialized', 'font-size: 20px; color: #ff8bd1')
    console.log('%cEmergent teen drama on a DOM game board.', 'font-size: 14px; color: #aaa')

    engine.start()
    monitorLifecycles()
    detectMeetings()
    updateDebug()
    trackFps()
    statsLabels()

    setInterval(likeGlassWhisper, 16000)
    setTimeout(() => updateMapNote('Map sensors live. Roads hum with latent drama.'), 1200)

    const initialChars = [characters[0], characters[1], characters[2]]
    initialChars.forEach((char, i) => {
      const positions = [
        { x: window.innerWidth * 0.35, y: window.innerHeight * 0.38 },
        { x: window.innerWidth * 0.6, y: window.innerHeight * 0.55 },
        { x: window.innerWidth * 0.2, y: window.innerHeight * 0.65 }
      ]
      setTimeout(() => spawnGhost(char, positions[i].x, positions[i].y), i * 900)
    })
  </script>
</body>
</html>
